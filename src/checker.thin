enum HeaderFlags {
  HEADER = 1 << 0,
  SOURCE = 1 << 1
}

class Header {
  name: string;
  flags: HeaderFlags;
  next: Header;
}

class CheckContext {
  log: Log;
  target: CompileTarget;
  pointerByteSize: int;
  isUnsafeAllowed: bool;
  enclosingClass: Symbol;
  currentFunction: Node;
  currentReturnType: Type;
  nextGlobalVariableOffset: int;
  isDebug: bool;

  // Native types
  boolType: Type;
  sbyteType: Type;
  errorType: Type;
  intType: Type;
  nullType: Type;
  shortType: Type;
  stringType: Type;
  byteType: Type;
  uintType: Type;
  ushortType: Type;
  voidType: Type;

  // Target specific headers
  firstHeader: Header;
  lastHeader: Header;

  allocateGlobalVariableOffset(sizeOf: int, alignmentOf: int): int {
    var offset = alignToNextMultipleOf(this.nextGlobalVariableOffset, alignmentOf);
    this.nextGlobalVariableOffset = offset + sizeOf;
    return offset;
  }

  addHeader(name: string, flags: int): void {
    var current = this.firstHeader;
    while (current != null) {
      if (current.name == name) {
        current.flags = (current.flags | flags) as HeaderFlags;
        return;
      }
      current = current.next;
    }

    var header = new Header();
    header.name = name;
    header.flags = flags as HeaderFlags;

    if (this.firstHeader == null) this.firstHeader = header;
    else this.lastHeader.next = header;
    this.lastHeader = header;
  }
}

function addScopeToSymbol(symbol: Symbol, parentScope: Scope): void {
  var scope = new Scope();
  scope.parent = parentScope;
  scope.symbol = symbol;
  symbol.scope = scope;
}

function linkSymbolToNode(symbol: Symbol, node: Node): void {
  node.symbol = symbol;
  node.scope = symbol.scope;
  symbol.range = node.internalRange != null ? node.internalRange : node.range;
  symbol.node = node;
}

enum CheckMode {
  NORMAL,
  INITIALIZE,
}

function initialize(context: CheckContext, node: Node, parentScope: Scope, mode: CheckMode): void {
  var kind = node.kind;

  if (node.parent != null) {
    var parentKind = node.parent.kind;

    // Validate node placement
    if (kind != NodeKind.VARIABLE && kind != NodeKind.VARIABLES && (kind != NodeKind.FUNCTION || parentKind != NodeKind.CLASS) &&
        (parentKind == NodeKind.FILE) != (kind == NodeKind.CLASS || kind == NodeKind.ENUM || kind == NodeKind.FUNCTION || kind == NodeKind.CONSTANTS)) {
      context.log.error(node.range, "This statement is not allowed here");
    }
  }

  // Class
  if (kind == NodeKind.CLASS || kind == NodeKind.ENUM) {
    assert(node.symbol == null);
    var symbol = new Symbol();
    symbol.kind = kind == NodeKind.CLASS ? SymbolKind.TYPE_CLASS : SymbolKind.TYPE_ENUM;
    symbol.name = node.stringValue;
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
    symbol.flags = SYMBOL_FLAG_IS_REFERENCE;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);
    parentScope.define(context.log, symbol, ScopeHint.NORMAL);
    parentScope = symbol.scope;
  }

  // Function
  else if (kind == NodeKind.FUNCTION) {
    assert(node.symbol == null);

    // Decorators modify functions at compile time before being resolved
    var decorators = node.firstChild;
    while (decorators != null) {
      if (decorators.kind == NodeKind.DECORATORS) break;
      decorators = decorators.nextSibling;
    }
    if (decorators != null) {
      var decorator = decorators.decoratorsFirstDecorator();
      while (decorator != null) {
        var name = decorator.decoratorName();
        if (name.stringValue == "builtin") decorator_builtin(node, context, decorator);
        else if (name.stringValue == "debug") decorator_debug(node, context, decorator);
        else if (name.stringValue == "global") decorator_global(node, context, decorator);
        else if (name.stringValue == "header") decorator_header(node, context, decorator);
        else if (name.stringValue == "metadata") decorator_metadata(node, context, decorator);
        else if (name.stringValue == "virtual") decorator_virtual(node, context, decorator);
        else context.log.error(node.range, "Illegal decorator");
        decorator = decorator.nextSibling;
      }
      decorators.remove();
    }

    var symbol = new Symbol();
    symbol.kind =
      node.parent.kind == NodeKind.CLASS ? SymbolKind.FUNCTION_INSTANCE :
      SymbolKind.FUNCTION_GLOBAL;
    symbol.name = node.stringValue;
    if (node.isOperator()) {
      if (symbol.name == "+" || symbol.name == "-") {
        if (node.functionFirstArgument() == node.functionReturnType()) {
          symbol.flags = SYMBOL_FLAG_IS_UNARY_OPERATOR;
          symbol.rename = symbol.name == "+" ? "op_positive" : "op_negative";
        } else {
          symbol.flags = SYMBOL_FLAG_IS_BINARY_OPERATOR;
          symbol.rename = symbol.name == "+" ? "op_add" : "op_subtract";
        }
      } else {
        symbol.rename =
          symbol.name == "%" ? "op_remainder" :
          symbol.name == "&" ? "op_and" :
          symbol.name == "*" ? "op_multiply" :
          symbol.name == "**" ? "op_exponent" :
          symbol.name == "++" ? "op_increment" :
          symbol.name == "--" ? "op_decrement" :
          symbol.name == "/" ? "op_divide" :
          symbol.name == "<" ? "op_lessThan" :
          symbol.name == "<<" ? "op_shiftLeft" :
          symbol.name == "==" ? "op_equals" :
          symbol.name == ">" ? "op_greaterThan" :
          symbol.name == ">>" ? "op_shiftRight" :
          symbol.name == "[]" ? "op_get" :
          symbol.name == "[]=" ? "op_set" :
          symbol.name == "^" ? "op_xor" :
          symbol.name == "|" ? "op_or" :
          symbol.name == "~" ? "op_complement" :
          null;
      }
    }
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);
    parentScope.define(context.log, symbol,
      symbol.isSetter() ? ScopeHint.NOT_GETTER :
      symbol.isGetter() ? ScopeHint.NOT_SETTER :
      symbol.isBinaryOperator() ? ScopeHint.NOT_UNARY :
      symbol.isUnaryOperator() ? ScopeHint.NOT_BINARY :
      ScopeHint.NORMAL);
    parentScope = symbol.scope;

    // All instance functions have a special "this" type
    if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
      var parent = symbol.parent();
      initializeSymbol(context, parent);
      node.insertChildBefore(node.functionFirstArgument(), createVariable("this", createType(parent.resolvedType), null));
    }
  }

  // Variable
  else if (kind == NodeKind.VARIABLE) {
    assert(node.symbol == null);
    var symbol = new Symbol();
    symbol.kind =
      node.parent.kind == NodeKind.CLASS ? SymbolKind.VARIABLE_INSTANCE :
      node.parent.kind == NodeKind.FUNCTION ? SymbolKind.VARIABLE_ARGUMENT :
      node.parent.kind == NodeKind.CONSTANTS || node.parent.kind == NodeKind.ENUM ? SymbolKind.VARIABLE_CONSTANT :
      node.parent.kind == NodeKind.VARIABLES && node.parent.parent.kind == NodeKind.FILE ? SymbolKind.VARIABLE_GLOBAL :
      SymbolKind.VARIABLE_LOCAL;
    symbol.name = node.stringValue;
    symbol.scope = parentScope;
    linkSymbolToNode(symbol, node);
    parentScope.define(context.log, symbol, ScopeHint.NORMAL);
  }

  // Block
  else if (kind == NodeKind.BLOCK) {
    if (node.parent.kind != NodeKind.FUNCTION) {
      var scope = new Scope();
      scope.parent = parentScope;
      parentScope = scope;
    }
    node.scope = parentScope;
  }

  // Children
  var child = node.firstChild;
  while (child != null) {
    initialize(context, child, parentScope, mode);
    child = child.nextSibling;
  }

  if (kind == NodeKind.FILE && mode == CheckMode.INITIALIZE) {
    context.boolType = parentScope.findLocal("bool", ScopeHint.NORMAL).resolvedType;
    context.byteType = parentScope.findLocal("byte", ScopeHint.NORMAL).resolvedType;
    context.intType = parentScope.findLocal("int", ScopeHint.NORMAL).resolvedType;
    context.sbyteType = parentScope.findLocal("sbyte", ScopeHint.NORMAL).resolvedType;
    context.shortType = parentScope.findLocal("short", ScopeHint.NORMAL).resolvedType;
    context.stringType = parentScope.findLocal("string", ScopeHint.NORMAL).resolvedType;
    context.uintType = parentScope.findLocal("uint", ScopeHint.NORMAL).resolvedType;
    context.ushortType = parentScope.findLocal("ushort", ScopeHint.NORMAL).resolvedType;

    prepareNativeType(context.boolType, 1, 0);
    prepareNativeType(context.byteType, 1, SYMBOL_FLAG_NATIVE_INTEGER | SYMBOL_FLAG_IS_UNSIGNED);
    prepareNativeType(context.intType, 4, SYMBOL_FLAG_NATIVE_INTEGER);
    prepareNativeType(context.sbyteType, 1, SYMBOL_FLAG_NATIVE_INTEGER);
    prepareNativeType(context.shortType, 2, SYMBOL_FLAG_NATIVE_INTEGER);
    prepareNativeType(context.stringType, 4, SYMBOL_FLAG_IS_REFERENCE);
    prepareNativeType(context.uintType, 4, SYMBOL_FLAG_NATIVE_INTEGER | SYMBOL_FLAG_IS_UNSIGNED);
    prepareNativeType(context.ushortType, 2, SYMBOL_FLAG_NATIVE_INTEGER | SYMBOL_FLAG_IS_UNSIGNED);
  }
}

function prepareNativeType(type: Type, byteSizeAndMaxAlignment: int, flags: int): void {
  var symbol = type.symbol;
  symbol.kind = SymbolKind.TYPE_NATIVE;
  symbol.byteSize = byteSizeAndMaxAlignment;
  symbol.maxAlignment = byteSizeAndMaxAlignment;
  symbol.flags = flags;
}

function forbidFlag(context: CheckContext, node: Node, flag: int, text: string): void {
  if ((node.flags & flag) != 0) {
    var range = rangeForFlag(node.firstFlag, flag);

    if (range != null) {
      node.flags = node.flags & ~flag;
      context.log.error(range, text);
    }
  }
}

function requireFlag(context: CheckContext, node: Node, flag: int, text: string): void {
  if ((node.flags & flag) == 0) {
    node.flags = node.flags | flag;
    context.log.error(node.range, text);
  }
}

function initializeSymbol(context: CheckContext, symbol: Symbol): void {
  if (symbol.state == SymbolState.INITIALIZED) {
    assert(symbol.resolvedType != null);
    return;
  }

  assert(symbol.state == SymbolState.UNINITIALIZED);
  symbol.state = SymbolState.INITIALIZING;

  // Most flags aren't supported yet
  var node = symbol.node;
  forbidFlag(context, node, NODE_FLAG_EXPORT, "Unsupported flag 'export'");
  forbidFlag(context, node, NODE_FLAG_PROTECTED, "Unsupported flag 'protected'");
  forbidFlag(context, node, NODE_FLAG_STATIC, "Unsupported flag 'static'");

  // Class
  if (symbol.kind == SymbolKind.TYPE_CLASS || symbol.kind == SymbolKind.TYPE_NATIVE) {
    forbidFlag(context, node, NODE_FLAG_GET, "Cannot use 'get' on a class");
    forbidFlag(context, node, NODE_FLAG_SET, "Cannot use 'set' on a class");
    forbidFlag(context, node, NODE_FLAG_PUBLIC, "Cannot use 'public' on a class");
    forbidFlag(context, node, NODE_FLAG_PRIVATE, "Cannot use 'private' on a class");
  }

  // Enum
  else if (symbol.kind == SymbolKind.TYPE_ENUM) {
    forbidFlag(context, node, NODE_FLAG_GET, "Cannot use 'get' on an enum");
    forbidFlag(context, node, NODE_FLAG_SET, "Cannot use 'set' on an enum");
    forbidFlag(context, node, NODE_FLAG_PUBLIC, "Cannot use 'public' on an enum");
    forbidFlag(context, node, NODE_FLAG_PRIVATE, "Cannot use 'private' on an enum");

    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
    var underlyingSymbol = symbol.resolvedType.underlyingType(context).symbol;
    symbol.byteSize = underlyingSymbol.byteSize;
    symbol.maxAlignment = underlyingSymbol.maxAlignment;
  }

  // Function
  else if (isFunction(symbol.kind)) {
    if (node.firstChild.kind == NodeKind.PARAMETERS) {
      resolve(context, node.firstChild, symbol.scope);
    }

    var body = node.functionBody();
    var returnType = node.functionReturnType();
    var oldUnsafeAllowed = context.isUnsafeAllowed;
    context.isUnsafeAllowed = node.isUnsafe();
    resolveAsType(context, returnType, symbol.scope.parent);

    var argumentCount = 0;
    var child = node.functionFirstArgument();
    while (child != returnType) {
      assert(child.kind == NodeKind.VARIABLE);
      assert(child.symbol.kind == SymbolKind.VARIABLE_ARGUMENT);
      initializeSymbol(context, child.symbol);
      child.symbol.offset = argumentCount;
      argumentCount = argumentCount + 1;
      child = child.nextSibling;
    }

    if (symbol.kind != SymbolKind.FUNCTION_INSTANCE) {
      forbidFlag(context, node, NODE_FLAG_GET, "Cannot use 'get' here");
      forbidFlag(context, node, NODE_FLAG_SET, "Cannot use 'set' here");
      forbidFlag(context, node, NODE_FLAG_PUBLIC, "Cannot use 'public' here");
      forbidFlag(context, node, NODE_FLAG_PRIVATE, "Cannot use 'private' here");
    }

    else if (node.isGet()) {
      forbidFlag(context, node, NODE_FLAG_SET, "Cannot use both 'get' and 'set'");

      // Validate argument count including "this"
      if (argumentCount != 1) {
        context.log.error(symbol.range, "Getters must not have any arguments");
      }
    }

    else if (node.isSet()) {
      symbol.rename = StringBuilder_new()
        .append("set_")
        .append(symbol.name)
        .finish();

      // Validate argument count including "this"
      if (argumentCount != 2) {
        context.log.error(symbol.range, "Setters must have exactly one argument");
      }
    }

    // Validate operator argument counts including "this"
    else if (node.isOperator()) {
      if (symbol.name == "~" || symbol.name == "++" || symbol.name == "--") {
        if (argumentCount != 1) {
          context.log.error(symbol.range, StringBuilder_new()
            .append("Operator '")
            .append(symbol.name)
            .append("' must not have any arguments")
            .finish());
        }
      }

      else if (symbol.name == "+" || symbol.name == "-") {
        if (argumentCount > 2) {
          context.log.error(symbol.range, StringBuilder_new()
            .append("Operator '")
            .append(symbol.name)
            .append("' must have at most one argument")
            .finish());
        }
      }

      else if (symbol.name == "[]=") {
        if (argumentCount < 2) {
          context.log.error(symbol.range, "Operator '[]=' must have at least one argument");
        }
      }

      else if (argumentCount != 2) {
        context.log.error(symbol.range, StringBuilder_new()
          .append("Operator '")
          .append(symbol.name)
          .append("' must have exactly one argument")
          .finish());
      }
    }

    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;

    if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
      var parent = symbol.parent();
      var shouldConvertInstanceToGlobal = false;

      forbidFlag(context, node, NODE_FLAG_EXTERN, "Cannot use 'extern' on an instance function");
      forbidFlag(context, node, NODE_FLAG_DECLARE, "Cannot use 'declare' on an instance function");

      // Functions inside declared classes are automatically declared
      if (parent.node.isDeclare()) {
        if (body == null) {
          node.flags = node.flags | NODE_FLAG_DECLARE;
        } else {
          shouldConvertInstanceToGlobal = true;
        }
      }

      // Require implementations for functions not on declared classes
      else {
        if (body == null) {
          context.log.error(node.lastChild.range, "Must implement this function");
        }

        // Functions inside extern classes are automatically extern
        if (parent.node.isExtern()) {
          node.flags = node.flags | NODE_FLAG_EXTERN;
        }
      }

      // Rewrite this symbol as a global function instead of an instance function
      if (shouldConvertInstanceToGlobal) {
        symbol.kind = SymbolKind.FUNCTION_GLOBAL;
        symbol.flags = symbol.flags | SYMBOL_FLAG_CONVERT_INSTANCE_TO_GLOBAL;
        symbol.rename = StringBuilder_new()
          .append(parent.name)
          .appendChar('_')
          .append(symbol.rename != null ? symbol.rename : symbol.name)
          .finish();
        var argument = node.functionFirstArgument();
        assert(argument.symbol.name == "this");
        argument.symbol.rename = "__this";
      }
    }

    // Imported functions require a modifier for consistency with TypeScript
    else if (body == null) {
      forbidFlag(context, node, NODE_FLAG_EXTERN, "Cannot use 'extern' on an unimplemented function");
      requireFlag(context, node, NODE_FLAG_DECLARE, "Declared functions must be prefixed with 'declare'");
    }

    else {
      forbidFlag(context, node, NODE_FLAG_DECLARE, "Cannot use 'declare' on a function with an implementation");
    }

    context.isUnsafeAllowed = oldUnsafeAllowed;
  }

  // Variable
  else if (isVariable(symbol.kind)) {
    forbidFlag(context, node, NODE_FLAG_GET, "Cannot use 'get' on a variable");
    forbidFlag(context, node, NODE_FLAG_SET, "Cannot use 'set' on a variable");

    var type = node.variableType();
    var value = node.variableValue();
    var oldUnsafeAllowed = context.isUnsafeAllowed;
    context.isUnsafeAllowed = context.isUnsafeAllowed || node.isUnsafe();

    if (symbol.kind != SymbolKind.VARIABLE_INSTANCE) {
      forbidFlag(context, node, NODE_FLAG_PUBLIC, "Cannot use 'public' here");
      forbidFlag(context, node, NODE_FLAG_PRIVATE, "Cannot use 'private' here");
    }

    if (type != null) {
      resolveAsType(context, type, symbol.scope);
      symbol.resolvedType = type.resolvedType;
    }

    else if (value != null) {
      resolveAsExpression(context, value, symbol.scope);
      symbol.resolvedType = value.resolvedType;
    }

    else {
      context.log.error(node.internalRange, "Cannot create untyped variables");
      symbol.resolvedType = context.errorType;
    }

    // Validate the variable type
    if (symbol.resolvedType == context.voidType || symbol.resolvedType == context.nullType) {
      context.log.error(node.internalRange, StringBuilder_new()
        .append("Cannot create a variable with type '")
        .append(symbol.resolvedType.toString())
        .appendChar('\'')
        .finish());
      symbol.resolvedType = context.errorType;
    }

    // Resolve constant values at initialization time
    if (symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
      if (value != null) {
        resolveAsExpression(context, value, symbol.scope);
        checkConversion(context, value, symbol.resolvedTypeUnderlyingIfEnumValue(context), ConversionKind.IMPLICIT);

        if (value.kind == NodeKind.INT || value.kind == NodeKind.BOOL) {
          symbol.offset = value.intValue;
        }

        else if (value.resolvedType != context.errorType) {
          context.log.error(value.range, "Invalid constant initializer");
          symbol.resolvedType = context.errorType;
        }
      }

      // Automatically initialize enum values using the previous enum
      else if (symbol.isEnumValue()) {
        if (node.previousSibling != null) {
          var previousSymbol = node.previousSibling.symbol;
          initializeSymbol(context, previousSymbol);
          symbol.offset = previousSymbol.offset + 1;
        } else {
          symbol.offset = 0;
        }
      }

      else {
        context.log.error(node.internalRange, "Constants must be initialized");
      }
    }

    // Disallow shadowing at function scope
    if (symbol.scope.symbol == null) {
      var scope = symbol.scope.parent;
      while (scope != null) {
        var shadowed = scope.findLocal(symbol.name, ScopeHint.NORMAL);
        if (shadowed != null) {
          context.log.error(node.internalRange, StringBuilder_new()
            .append("The symbol '")
            .append(symbol.name)
            .append("' shadows another symbol with the same name in a parent scope")
            .finish());
          break;
        }

        // Stop when we pass through a function scope
        if (scope.symbol != null) {
          break;
        }
        scope = scope.parent;
      }
    }

    context.isUnsafeAllowed = oldUnsafeAllowed;
  }

  else {
    assert(false);
  }

  assert(symbol.resolvedType != null);
  symbol.state = SymbolState.INITIALIZED;
}

function resolveChildren(context: CheckContext, node: Node, parentScope: Scope): void {
  var child = node.firstChild;
  while (child != null) {
    resolve(context, child, parentScope);
    assert(child.resolvedType != null);
    child = child.nextSibling;
  }
}

function resolveChildrenAsExpressions(context: CheckContext, node: Node, parentScope: Scope): void {
  var child = node.firstChild;
  while (child != null) {
    resolveAsExpression(context, child, parentScope);
    child = child.nextSibling;
  }
}

function resolveAsExpression(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(isExpression(node));
  resolve(context, node, parentScope);
  assert(node.resolvedType != null);

  if (node.resolvedType != context.errorType) {
    if (node.isType()) {
      context.log.error(node.range, "Expected expression but found type");
      node.resolvedType = context.errorType;
    }

    else if (node.resolvedType == context.voidType && node.parent.kind != NodeKind.EXPRESSION) {
      context.log.error(node.range, "This expression does not return a value");
      node.resolvedType = context.errorType;
    }
  }
}

function resolveAsType(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(isExpression(node));
  resolve(context, node, parentScope);
  assert(node.resolvedType != null);

  if (node.resolvedType != context.errorType && !node.isType()) {
    context.log.error(node.range, "Expected type but found expression");
    node.resolvedType = context.errorType;
  }
}

function canConvert(context: CheckContext, node: Node, to: Type, kind: ConversionKind): bool {
  var from = node.resolvedType;

  assert(isExpression(node));
  assert(from != null);
  assert(to != null);

  // Early-out if the types are identical or errors
  if (from == to || from == context.errorType || to == context.errorType) {
    return true;
  }

  // Allow conversions from null
  else if (from == context.nullType && to.isReference()) {
    return true;
  }

  // Allow explicit conversions between references in unsafe mode
  else if (context.isUnsafeAllowed && (from.isReference() || to.isReference())) {
    if (kind == ConversionKind.EXPLICIT) {
      return true;
    }
  }

  // Check integer conversions
  else if (from.isInteger() && to.isInteger()) {
    var mask = to.integerBitMask(context);

    // Allow implicit conversions between enums and int
    if (from.isEnum() && to == from.underlyingType(context)) {
      return true;
    }

    // Only allow lossless conversions implicitly
    if (kind == ConversionKind.EXPLICIT || from.symbol.byteSize < to.symbol.byteSize ||
        node.kind == NodeKind.INT && (to.isUnsigned()
          ? node.intValue >= 0 && node.intValue as uint <= mask
          : node.intValue >= (~mask as int >> 1) && node.intValue <= (mask >> 1) as int)) {
      return true;
    }
  }

  return false;
}

function checkConversion(context: CheckContext, node: Node, to: Type, kind: ConversionKind): void {
  if (!canConvert(context, node, to, kind)) {
    context.log.error(node.range, StringBuilder_new()
      .append("Cannot convert from type '")
      .append(node.resolvedType.toString())
      .append("' to type '")
      .append(to.toString())
      .append(kind == ConversionKind.IMPLICIT && canConvert(context, node, to, ConversionKind.EXPLICIT) ? "' without a cast" : "'")
      .finish());
    node.resolvedType = context.errorType;
  }
}

function checkStorage(context: CheckContext, target: Node): void {
  assert(isExpression(target));

  if (target.resolvedType != context.errorType && target.kind != NodeKind.INDEX && target.kind != NodeKind.DEREFERENCE &&
      (target.kind != NodeKind.NAME && target.kind != NodeKind.DOT || target.symbol != null && (!isVariable(target.symbol.kind) || target.symbol.kind == SymbolKind.VARIABLE_CONSTANT))) {
    context.log.error(target.range, "Cannot store to this location");
    target.resolvedType = context.errorType;
  }
}

function createDefaultValueForType(context: CheckContext, type: Type): Node {
  if (type.isInteger()) {
    return createInt(0);
  }

  if (type == context.boolType) {
    return createBool(false);
  }

  assert(type.isReference());
  return createNull();
}

function simplifyBinary(node: Node): void {
  var left = node.binaryLeft();
  var right = node.binaryRight();

  // Canonicalize commutative operators
  if ((node.kind == NodeKind.ADD || node.kind == NodeKind.MULTIPLY ||
      node.kind == NodeKind.BITWISE_AND || node.kind == NodeKind.BITWISE_OR || node.kind == NodeKind.BITWISE_XOR) &&
      left.kind == NodeKind.INT && right.kind != NodeKind.INT) {
    node.appendChild(left.remove());
    left = node.binaryLeft();
    right = node.binaryRight();
  }

  // Convert multiplication or division by a power of 2 into a shift
  if ((node.kind == NodeKind.MULTIPLY || (node.kind == NodeKind.DIVIDE || node.kind == NodeKind.REMAINDER) && node.resolvedType.isUnsigned()) &&
      right.kind == NodeKind.INT && isPositivePowerOf2(right.intValue)) {
    // Extract the shift from the value
    var shift = -1;
    var value = right.intValue;
    while (value != 0) {
      value = value >> 1;
      shift = shift + 1;
    }

    // "x * 16" => "x << 4"
    if (node.kind == NodeKind.MULTIPLY) {
      node.kind = NodeKind.SHIFT_LEFT;
      right.intValue = shift;
    }

    // "x / 16" => "x >> 4" when x is unsigned
    else if (node.kind == NodeKind.DIVIDE) {
      node.kind = NodeKind.SHIFT_RIGHT;
      right.intValue = shift;
    }

    // "x % 16" => "x & 15" when x is unsigned
    else if (node.kind == NodeKind.REMAINDER) {
      node.kind = NodeKind.BITWISE_AND;
      right.intValue = right.intValue - 1;
    }

    else {
      assert(false);
    }
  }

  // Flip addition with negation into subtraction
  else if (node.kind == NodeKind.ADD && right.kind == NodeKind.NEGATIVE) {
    node.kind = NodeKind.SUBTRACT;
    right.replaceWith(right.unaryValue().remove());
  }

  // Flip addition with negative constants into subtraction
  else if (node.kind == NodeKind.ADD && right.isNegativeInteger()) {
    node.kind = NodeKind.SUBTRACT;
    right.intValue = -right.intValue;
  }
}

function binaryHasUnsignedArguments(node: Node): bool {
  var left = node.binaryLeft();
  var right = node.binaryRight();
  var leftType = left.resolvedType;
  var rightType = right.resolvedType;

  return (
    leftType.isUnsigned() && rightType.isUnsigned() ||
    leftType.isUnsigned() && right.isNonNegativeInteger() ||
    left.isNonNegativeInteger() && rightType.isUnsigned()
  );
}

function isSymbolAccessAllowed(context: CheckContext, symbol: Symbol, node: Node, range: Range): bool {
  if (symbol.isUnsafe() && !context.isUnsafeAllowed) {
    context.log.error(range, StringBuilder_new()
      .append("Cannot use symbol '")
      .append(symbol.name)
      .append("' outside an 'unsafe' block")
      .finish());
    return false;
  }

  if (symbol.node != null && symbol.node.isPrivate()) {
    var parent = symbol.parent();

    if (parent != null && context.enclosingClass != parent) {
      context.log.error(range, StringBuilder_new()
        .append("Cannot access private symbol '")
        .append(symbol.name)
        .append("' here")
        .finish());
      return false;
    }
  }

  if (isFunction(symbol.kind) && (symbol.isSetter() ? !node.isAssignTarget() : !node.isCallValue())) {
    if (symbol.isSetter()) {
      context.log.error(range, StringBuilder_new()
        .append("Cannot use setter '")
        .append(symbol.name)
        .append("' here")
        .finish());
    }

    else {
      context.log.error(range, StringBuilder_new()
        .append("Must call function '")
        .append(symbol.name)
        .appendChar('\'')
        .finish());
    }

    return false;
  }
  return true;
}

function resolve(context: CheckContext, node: Node, parentScope: Scope): void {
  var kind = node.kind;
  assert(kind == NodeKind.FILE || parentScope != null);

  // Already resolved
  if (node.resolvedType != null) {
    return;
  }

  node.resolvedType = context.errorType;

  if (kind == NodeKind.FILE || kind == NodeKind.GLOBAL) {
    resolveChildren(context, node, parentScope);
  }

  else if (kind == NodeKind.CLASS) {
    var oldEnclosingClass = context.enclosingClass;
    initializeSymbol(context, node.symbol);
    context.enclosingClass = node.symbol;
    resolveChildren(context, node, node.scope);
    if (node.symbol.kind == SymbolKind.TYPE_CLASS) {
      node.symbol.determineClassLayout(context);
    }
    context.enclosingClass = oldEnclosingClass;
  }

  else if (kind == NodeKind.ENUM) {
    initializeSymbol(context, node.symbol);
    resolveChildren(context, node, node.scope);
  }

  else if (kind == NodeKind.FUNCTION) {
    var body = node.functionBody();
    initializeSymbol(context, node.symbol);

    if (body != null) {
      var oldFunction = context.currentFunction;
      var oldReturnType = context.currentReturnType;
      var oldUnsafeAllowed = context.isUnsafeAllowed;
      context.currentFunction = node;
      context.currentReturnType = node.functionReturnType().resolvedType;
      context.isUnsafeAllowed = node.isUnsafe();
      resolveChildren(context, body, node.scope);
      context.currentFunction = oldFunction;
      context.currentReturnType = oldReturnType;
      context.isUnsafeAllowed = oldUnsafeAllowed;
    }
  }

  else if (kind == NodeKind.VARIABLE) {
    var symbol = node.symbol;
    initializeSymbol(context, symbol);

    var oldUnsafeAllowed = context.isUnsafeAllowed;
    context.isUnsafeAllowed = context.isUnsafeAllowed || node.isUnsafe();

    var value = node.variableValue();
    if (value != null) {
      resolveAsExpression(context, value, parentScope);
      checkConversion(context, value, symbol.resolvedTypeUnderlyingIfEnumValue(context), ConversionKind.IMPLICIT);

      // Variable initializers must be compile-time constants
      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL && value.kind != NodeKind.INT && value.kind != NodeKind.BOOL && value.kind != NodeKind.NULL) {
        context.log.error(value.range, "Global initializers must be compile-time constants");
      }
    }

    else if (symbol.resolvedType != context.errorType) {
      value = createDefaultValueForType(context, symbol.resolvedType);
      resolveAsExpression(context, value, parentScope);
      node.appendChild(value);
    }

    // Allocate global variables
    if (symbol.kind == SymbolKind.VARIABLE_GLOBAL && symbol.resolvedType != context.errorType) {
      symbol.offset = context.allocateGlobalVariableOffset(symbol.resolvedType.variableSizeOf(context), symbol.resolvedType.variableAlignmentOf(context));
    }

    context.isUnsafeAllowed = oldUnsafeAllowed;
  }

  else if (kind == NodeKind.BREAK || kind == NodeKind.CONTINUE) {
    var found = false;
    var n = node;
    while (n != null) {
      if (n.kind == NodeKind.WHILE) {
        found = true;
        break;
      }
      n = n.parent;
    }
    if (!found) {
      context.log.error(node.range, "Cannot use this statement outside of a loop");
    }
  }

  else if (kind == NodeKind.BLOCK) {
    var oldUnsafeAllowed = context.isUnsafeAllowed;
    if (node.isUnsafe()) context.isUnsafeAllowed = true;
    resolveChildren(context, node, node.scope);
    context.isUnsafeAllowed = oldUnsafeAllowed;
  }

  else if (kind == NodeKind.CONSTANTS || kind == NodeKind.VARIABLES) {
    resolveChildren(context, node, parentScope);
  }

  else if (kind == NodeKind.INT) {
    // Use the positive flag to differentiate between -2147483648 and 2147483648
    node.resolvedType = node.intValue < 0 && !node.isPositive() ? context.uintType : context.intType;
  }

  else if (kind == NodeKind.STRING) {
    node.resolvedType = context.stringType;
  }

  else if (kind == NodeKind.BOOL) {
    node.resolvedType = context.boolType;
  }

  else if (kind == NodeKind.NULL) {
    node.resolvedType = context.nullType;
  }

  else if (kind == NodeKind.INDEX) {
    resolveChildrenAsExpressions(context, node, parentScope);

    var target = node.indexTarget();
    var type = target.resolvedType;

    if (type != context.errorType) {
      var symbol = type.hasInstanceMembers() ? type.findMember("[]", ScopeHint.NORMAL) : null;

      if (symbol == null) {
        context.log.error(node.internalRange, StringBuilder_new()
          .append("Cannot index into type '")
          .append(target.resolvedType.toString())
          .appendChar('\'')
          .finish());
      }

      else {
        assert(symbol.kind == SymbolKind.FUNCTION_INSTANCE || symbol.kind == SymbolKind.FUNCTION_GLOBAL && symbol.shouldConvertInstanceToGlobal());

        // Convert to a regular function call and resolve that instead
        node.kind = NodeKind.CALL;
        target.remove();
        node.insertChildBefore(node.firstChild, createMemberReference(target, symbol));
        node.resolvedType = null;
        resolveAsExpression(context, node, parentScope);
      }
    }
  }

  else if (kind == NodeKind.ALIGN_OF) {
    var alignOfType = node.alignOfType();
    resolveAsType(context, alignOfType, parentScope);
    node.resolvedType = context.intType;

    if (alignOfType.resolvedType != context.errorType) {
      node.becomeIntegerConstant(alignOfType.resolvedType.allocationAlignmentOf(context));
    }
  }

  else if (kind == NodeKind.SIZE_OF) {
    var sizeOfType = node.sizeOfType();
    resolveAsType(context, sizeOfType, parentScope);
    node.resolvedType = context.intType;

    if (sizeOfType.resolvedType != context.errorType) {
      node.becomeIntegerConstant(sizeOfType.resolvedType.allocationSizeOf(context));
    }
  }

  else if (kind == NodeKind.THIS) {
    var symbol = parentScope.findNested("this", ScopeHint.NORMAL, FindNested.NORMAL);
    if (symbol == null) {
      context.log.error(node.range, "Cannot use 'this' here");
    } else {
      node.becomeSymbolReference(symbol);
    }
  }

  else if (kind == NodeKind.PARSE_ERROR) {
    node.resolvedType = context.errorType;
  }

  else if (kind == NodeKind.NAME) {
    var name = node.stringValue;
    var symbol = parentScope.findNested(name, ScopeHint.NORMAL, FindNested.NORMAL);

    if (symbol == null) {
      var builder = StringBuilder_new()
        .append("No symbol named '")
        .append(name)
        .append("' here");

      // In JavaScript, "this." before instance symbols is required
      symbol = parentScope.findNested(name, ScopeHint.NORMAL, FindNested.ALLOW_INSTANCE_ERRORS);
      if (symbol != null) {
        builder
          .append(", did you mean 'this.")
          .append(symbol.name)
          .append("'?");
      }

      // People may try to use types from TypeScript
      else if (name == "number") builder.append(", did you mean 'int'?");
      else if (name == "boolean") builder.append(", did you mean 'bool'?");

      context.log.error(node.range, builder.finish());
    }

    else if (symbol.state == SymbolState.INITIALIZING) {
      context.log.error(node.range, StringBuilder_new()
        .append("Cyclic reference to symbol '")
        .append(name)
        .append("' here")
        .finish());
    }

    else if (isSymbolAccessAllowed(context, symbol, node, node.range)) {
      initializeSymbol(context, symbol);
      node.symbol = symbol;
      node.resolvedType = symbol.resolvedType;

      // Inline constants
      if (symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
        if (symbol.resolvedType == context.boolType) {
          node.becomeBooleanConstant(symbol.offset != 0);
        } else {
          node.becomeIntegerConstant(symbol.offset);
        }
      }
    }
  }

  else if (kind == NodeKind.CAST) {
    var castValue = node.castValue();
    var castType = node.castType();
    resolveAsExpression(context, castValue, parentScope);
    resolveAsType(context, castType, parentScope);
    var castedType = castType.resolvedType;
    checkConversion(context, castValue, castedType, ConversionKind.EXPLICIT);
    node.resolvedType = castedType;

    // Automatically fold constants
    if (castValue.kind == NodeKind.INT && castedType.isInteger()) {
      var result = castValue.intValue;
      var shift = 32 - castedType.integerBitCount(context);
      node.becomeIntegerConstant(castedType.isUnsigned()
        ? (castedType.integerBitMask(context) as int) & result
        : result << shift >> shift);
    }
  }

  else if (kind == NodeKind.DOT) {
    var target = node.dotTarget();
    resolve(context, target, parentScope);

    if (target.resolvedType != context.errorType) {
      if (target.isType() && target.resolvedType.isEnum() ||
          !target.isType() && target.resolvedType.hasInstanceMembers()) {
        var name = node.stringValue;

        // Empty names are left over from parse errors that have already been reported
        if (name.length > 0) {
          var symbol = target.resolvedType.findMember(name, node.isAssignTarget() ? ScopeHint.PREFER_SETTER : ScopeHint.PREFER_GETTER);

          if (symbol == null) {
            context.log.error(node.internalRange, StringBuilder_new()
              .append("No member named '")
              .append(name)
              .append("' on type '")
              .append(target.resolvedType.toString())
              .appendChar('\'')
              .finish());
          }

          // Automatically call getters
          else if (symbol.isGetter()) {
            node.kind = NodeKind.CALL;
            node.appendChild(createMemberReference(target.remove(), symbol));
            node.resolvedType = null;
            resolveAsExpression(context, node, parentScope);
            return;
          }

          else if (isSymbolAccessAllowed(context, symbol, node, node.internalRange)) {
            initializeSymbol(context, symbol);
            node.symbol = symbol;
            node.resolvedType = symbol.resolvedType;

            // Inline constants
            if (symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
              node.becomeIntegerConstant(symbol.offset);
            }
          }
        }
      }

      else {
        context.log.error(node.internalRange, StringBuilder_new()
          .append("The type '")
          .append(target.resolvedType.toString())
          .append("' has no members")
          .finish());
      }
    }
  }

  else if (kind == NodeKind.CALL) {
    var value = node.callValue();
    resolveAsExpression(context, value, parentScope);

    if (value.resolvedType != context.errorType) {
      var symbol = value.symbol;

      // Only functions are callable
      if (symbol == null || !isFunction(symbol.kind)) {
        context.log.error(value.range, StringBuilder_new()
          .append("Cannot call value of type '")
          .append(value.resolvedType.toString())
          .appendChar('\'')
          .finish());
      }

      else {
        initializeSymbol(context, symbol);

        if (symbol.shouldConvertInstanceToGlobal()) {
          var reference = createSymbolReference(symbol);
          node.insertChildBefore(value, reference.withRange(value.internalRange));
          node.insertChildBefore(value, value.dotTarget().remove());
          value.remove();
          value = reference;
        }

        var returnType = symbol.node.functionReturnType();
        var argumentVariable = symbol.node.functionFirstArgumentIgnoringThis();
        var argumentValue = value.nextSibling;

        // Match argument values with variables
        while (argumentVariable != returnType && argumentValue != null) {
          resolveAsExpression(context, argumentValue, parentScope);
          checkConversion(context, argumentValue, argumentVariable.symbol.resolvedType, ConversionKind.IMPLICIT);
          argumentVariable = argumentVariable.nextSibling;
          argumentValue = argumentValue.nextSibling;
        }

        // Not enough arguments?
        if (argumentVariable != returnType) {
          context.log.error(node.internalRange, StringBuilder_new()
            .append("Not enough arguments for function '")
            .append(symbol.name)
            .appendChar('\'')
            .finish());
        }

        // Too many arguments?
        else if (argumentValue != null) {
          while (argumentValue != null) {
            resolveAsExpression(context, argumentValue, parentScope);
            argumentValue = argumentValue.nextSibling;
          }
          context.log.error(node.internalRange, StringBuilder_new()
            .append("Too many arguments for function '")
            .append(symbol.name)
            .appendChar('\'')
            .finish());
        }

        // Pass the return type along
        node.resolvedType = returnType.resolvedType;
      }
    }
  }

  else if (kind == NodeKind.RETURN) {
    var value = node.returnValue();

    if (context.currentFunction.isConstructor()) {
      context.log.error(node.range, "Constructors cannot return a value");
    }

    else if (value != null) {
      resolveAsExpression(context, value, parentScope);

      if (context.currentReturnType != null) {
        if (context.currentReturnType != context.voidType) {
          checkConversion(context, value, context.currentReturnType, ConversionKind.IMPLICIT);
        }

        else {
          context.log.error(value.range, "Unexpected return value in function returning 'void'");
        }
      }
    }

    else if (context.currentReturnType != null && context.currentReturnType != context.voidType) {
      context.log.error(node.range, StringBuilder_new()
        .append("Expected return value in function returning '")
        .append(context.currentReturnType.toString())
        .appendChar('\'')
        .finish());
    }
  }

  else if (kind == NodeKind.EMPTY) {
  }

  else if (kind == NodeKind.PARAMETERS) {
    context.log.error(node.range, "Generics are not implemented yet");
  }

  else if (kind == NodeKind.EXTENDS) {
    resolveAsType(context, node.extendsType(), parentScope);
    context.log.error(node.range, "Subclassing is not implemented yet");
  }

  else if (kind == NodeKind.IMPLEMENTS) {
    var child = node.implementsFirstType();
    while (child != null) {
      resolveAsType(context, child, parentScope);
      child = child.nextSibling;
    }
    context.log.error(node.range, "Interfaces are not implemented yet");
  }

  else if (kind == NodeKind.EXPRESSION) {
    resolveAsExpression(context, node.expressionValue(), parentScope);
  }

  else if (kind == NodeKind.WHILE) {
    var value = node.whileValue();
    var body = node.whileBody();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    resolve(context, body, parentScope);
  }

  else if (kind == NodeKind.IF) {
    var value = node.ifValue();
    var yes = node.ifTrue();
    var no = node.ifFalse();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    resolve(context, yes, parentScope);
    if (no != null) {
      resolve(context, no, parentScope);
    }
  }

  else if (kind == NodeKind.HOOK) {
    var value = node.hookValue();
    var yes = node.hookTrue();
    var no = node.hookFalse();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    resolve(context, yes, parentScope);
    resolve(context, no, parentScope);
    var commonType = (yes.resolvedType == context.nullType ? no : yes).resolvedType;
    if (yes.resolvedType != commonType && (yes.resolvedType != context.nullType || !commonType.isReference()) &&
        no.resolvedType != commonType && (no.resolvedType != context.nullType || !commonType.isReference())) {
      context.log.error(spanRanges(yes.range, no.range), StringBuilder_new()
        .append("Type '")
        .append(yes.resolvedType.toString())
        .append("' is not the same as type '")
        .append(no.resolvedType.toString())
        .appendChar('\'')
        .finish());
    }
    node.resolvedType = commonType;
  }

  else if (kind == NodeKind.ASSIGN) {
    var left = node.binaryLeft();
    var right = node.binaryRight();

    if (left.kind == NodeKind.INDEX) {
      resolveChildrenAsExpressions(context, left, parentScope);

      var target = left.indexTarget();
      var type = target.resolvedType;

      if (type != context.errorType) {
        var symbol = type.hasInstanceMembers() ? type.findMember("[]=", ScopeHint.NORMAL) : null;

        if (symbol == null) {
          context.log.error(left.internalRange, StringBuilder_new()
            .append("Cannot index into type '")
            .append(target.resolvedType.toString())
            .appendChar('\'')
            .finish());
        }

        else {
          assert(symbol.kind == SymbolKind.FUNCTION_INSTANCE);

          // Convert to a regular function call and resolve that instead
          node.kind = NodeKind.CALL;
          target.remove();
          left.remove();
          while (left.lastChild != null) {
            node.insertChildBefore(node.firstChild, left.lastChild.remove());
          }
          node.insertChildBefore(node.firstChild, createMemberReference(target, symbol));
          node.internalRange = spanRanges(left.internalRange, right.range);
          node.resolvedType = null;
          resolveAsExpression(context, node, parentScope);
          return;
        }
      }
    }

    resolveAsExpression(context, left, parentScope);

    // Automatically call setters
    if (left.symbol != null && left.symbol.isSetter()) {
      node.kind = NodeKind.CALL;
      node.internalRange = left.internalRange;
      node.resolvedType = null;
      resolveAsExpression(context, node, parentScope);
      return;
    }

    resolveAsExpression(context, right, parentScope);
    checkConversion(context, right, left.resolvedType, ConversionKind.IMPLICIT);
    checkStorage(context, left);
    node.resolvedType = left.resolvedType;
  }

  else if (kind == NodeKind.NEW) {
    var newType = node.newType();
    resolveAsType(context, newType, parentScope);

    if (newType.resolvedType != context.errorType) {
      if (!newType.resolvedType.isClass() || newType.resolvedType.symbol.kind == SymbolKind.TYPE_NATIVE) {
        context.log.error(newType.range, StringBuilder_new()
          .append("Cannot construct type '")
          .append(newType.resolvedType.toString())
          .appendChar('\'')
          .finish());
      }

      else {
        node.resolvedType = newType.resolvedType;

        var argumentValue = node.newFirstArgument();
        var ctor = newType.symbol.node.classConstructor();

        if (ctor != null) {
          var argumentVariable = ctor.functionFirstArgumentIgnoringThis();
          var returnType = ctor.functionReturnType();
          assert(newType.resolvedType == returnType.resolvedType);

          // Match argument values with variables
          while (argumentVariable != returnType && argumentValue != null) {
            resolveAsExpression(context, argumentValue, parentScope);
            checkConversion(context, argumentValue, argumentVariable.symbol.resolvedType, ConversionKind.IMPLICIT);
            argumentVariable = argumentVariable.nextSibling;
            argumentValue = argumentValue.nextSibling;
          }

          // Not enough arguments?
          if (argumentVariable != returnType) {
            context.log.error(node.internalRange, StringBuilder_new()
              .append("Not enough arguments for constructor '")
              .append(newType.symbol.name)
              .appendChar('\'')
              .finish());
          }
        }

        // Too many arguments?
        if (argumentValue != null) {
          while (argumentValue != null) {
            resolveAsExpression(context, argumentValue, parentScope);
            argumentValue = argumentValue.nextSibling;
          }
          context.log.error(node.internalRange, StringBuilder_new()
            .append("Too many arguments for constructor '")
            .append(newType.symbol.name)
            .appendChar('\'')
            .finish());
        }
      }
    }
  }

  else if (kind == NodeKind.POINTER_TYPE) {
    var value = node.unaryValue();
    resolveAsType(context, value, parentScope);

    if (context.target == CompileTarget.JAVASCRIPT) {
      context.log.error(node.internalRange, "Cannot use pointers when compiling to JavaScript");
    }

    else if (!context.isUnsafeAllowed) {
      context.log.error(node.internalRange, "Cannot use pointers outside an 'unsafe' block");
    }

    else {
      var type = value.resolvedType;

      if (type != context.errorType) {
        if (!type.isInteger() && type.pointerTo == null) {
          context.log.error(node.internalRange, StringBuilder_new()
            .append("Cannot create a pointer to non-integer type '")
            .append(type.toString())
            .appendChar('\'')
            .finish());
        }

        else {
          node.resolvedType = type.pointerType();
        }
      }
    }
  }

  else if (kind == NodeKind.DEREFERENCE) {
    var value = node.unaryValue();
    resolveAsExpression(context, value, parentScope);
    var type = value.resolvedType;

    if (type != context.errorType) {
      if (type.pointerTo == null) {
        context.log.error(node.internalRange, StringBuilder_new()
          .append("Cannot dereference type '")
          .append(type.toString())
          .appendChar('\'')
          .finish());
      }

      else {
        node.resolvedType = type.pointerTo;
      }
    }
  }

  else if (kind == NodeKind.ADDRESS_OF) {
    var value = node.unaryValue();
    resolveAsExpression(context, value, parentScope);
    context.log.error(node.internalRange, "The address-of operator is not supported");
  }

  else if (isUnary(kind)) {
    var value = node.unaryValue();
    resolveAsExpression(context, value, parentScope);

    // Operator "!" is hard-coded
    if (kind == NodeKind.NOT) {
      checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
      node.resolvedType = context.boolType;
    }

    // Special-case integer types
    else if (value.resolvedType.isInteger()) {
      if (value.resolvedType.isUnsigned()) {
        node.flags = node.flags | NODE_FLAG_UNSIGNED_OPERATOR;
        node.resolvedType = context.uintType;
      } else {
        node.resolvedType = context.intType;
      }

      // Automatically fold constants
      if (value.kind == NodeKind.INT) {
        var input = value.intValue;
        var output = input;
        if (kind == NodeKind.COMPLEMENT) output = ~input;
        else if (kind == NodeKind.NEGATIVE) output = -input;
        node.becomeIntegerConstant(output);
      }
    }

    // Support custom operators
    else if (value.resolvedType != context.errorType) {
      var name = node.internalRange.toString();
      var symbol = value.resolvedType.findMember(name, ScopeHint.NOT_BINARY);

      // Automatically call the function
      if (symbol != null) {
        node.appendChild(createMemberReference(value.remove(), symbol).withRange(node.range).withInternalRange(node.internalRange));
        node.kind = NodeKind.CALL;
        node.resolvedType = null;
        resolveAsExpression(context, node, parentScope);
      }

      else {
        context.log.error(node.internalRange, StringBuilder_new()
          .append("Cannot use unary operator '")
          .append(name)
          .append("' with type '")
          .append(value.resolvedType.toString())
          .appendChar('\'')
          .finish());
      }
    }
  }

  else if (isBinary(kind)) {
    var left = node.binaryLeft();
    var right = node.binaryRight();

    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);

    var leftType = left.resolvedType;
    var rightType = right.resolvedType;

    // Operators "&&" and "||" are hard-coded
    if (kind == NodeKind.LOGICAL_OR || kind == NodeKind.LOGICAL_AND) {
      checkConversion(context, left, context.boolType, ConversionKind.IMPLICIT);
      checkConversion(context, right, context.boolType, ConversionKind.IMPLICIT);
      node.resolvedType = context.boolType;
    }

    // Special-case pointer types (it's the emitter's job to scale the integer delta by the size of the pointer target)
    else if (kind == NodeKind.ADD && leftType.pointerTo != null && rightType.isInteger()) {
      node.resolvedType = leftType;
    }

    // Special-case pointer types
    else if ((kind == NodeKind.LESS_THAN || kind == NodeKind.LESS_THAN_EQUAL ||
        kind == NodeKind.GREATER_THAN || kind == NodeKind.GREATER_THAN_EQUAL) && (
        leftType.pointerTo != null || rightType.pointerTo != null)) {
      node.resolvedType = context.boolType;

      // Both pointer types must be exactly the same
      if (leftType != rightType) {
        context.log.error(node.internalRange, StringBuilder_new()
          .append("Cannot compare type '")
          .append(leftType.toString())
          .append("' with type '")
          .append(rightType.toString())
          .appendChar('\'')
          .finish());
      }
    }

    // Operators for integers are hard-coded
    else if (leftType.isInteger() && kind != NodeKind.EQUAL && kind != NodeKind.NOT_EQUAL) {
      // Arithmetic operators
      if (kind == NodeKind.ADD ||
          kind == NodeKind.SUBTRACT ||
          kind == NodeKind.MULTIPLY ||
          kind == NodeKind.DIVIDE ||
          kind == NodeKind.REMAINDER ||
          kind == NodeKind.BITWISE_AND ||
          kind == NodeKind.BITWISE_OR ||
          kind == NodeKind.BITWISE_XOR ||
          kind == NodeKind.SHIFT_LEFT ||
          kind == NodeKind.SHIFT_RIGHT) {
        var isUnsigned = binaryHasUnsignedArguments(node);
        var commonType = isUnsigned ? context.uintType : context.intType;
        if (isUnsigned) {
          node.flags = node.flags | NODE_FLAG_UNSIGNED_OPERATOR;
        }
        checkConversion(context, left, commonType, ConversionKind.IMPLICIT);
        checkConversion(context, right, commonType, ConversionKind.IMPLICIT);
        node.resolvedType = commonType;

        // Automatically fold constants
        if (left.kind == NodeKind.INT && right.kind == NodeKind.INT) {
          var inputLeft = left.intValue;
          var inputRight = right.intValue;
          var output = 0;
          if (kind == NodeKind.ADD) output = inputLeft + inputRight;
          else if (kind == NodeKind.BITWISE_AND) output = inputLeft & inputRight;
          else if (kind == NodeKind.BITWISE_OR) output = inputLeft | inputRight;
          else if (kind == NodeKind.BITWISE_XOR) output = inputLeft ^ inputRight;
          else if (kind == NodeKind.DIVIDE) output = inputLeft / inputRight;
          else if (kind == NodeKind.MULTIPLY) output = inputLeft * inputRight;
          else if (kind == NodeKind.REMAINDER) output = inputLeft % inputRight;
          else if (kind == NodeKind.SHIFT_LEFT) output = inputLeft << inputRight;
          else if (kind == NodeKind.SHIFT_RIGHT) output = isUnsigned ? ((inputLeft as uint) >> (inputRight as uint)) as int : inputLeft >> inputRight;
          else if (kind == NodeKind.SUBTRACT) output = inputLeft - inputRight;
          else return;
          node.becomeIntegerConstant(output);
        }

        else {
          simplifyBinary(node);
        }
      }

      // Comparison operators
      else if (
          kind == NodeKind.LESS_THAN ||
          kind == NodeKind.LESS_THAN_EQUAL ||
          kind == NodeKind.GREATER_THAN ||
          kind == NodeKind.GREATER_THAN_EQUAL) {
        var expectedType =
          binaryHasUnsignedArguments(node) ? context.uintType :
          context.intType;

        if (expectedType == context.uintType) {
          node.flags = node.flags | NODE_FLAG_UNSIGNED_OPERATOR;
        }

        if (leftType != rightType) {
          checkConversion(context, left, expectedType, ConversionKind.IMPLICIT);
          checkConversion(context, right, expectedType, ConversionKind.IMPLICIT);
        }

        node.resolvedType = context.boolType;
      }

      else {
        context.log.error(node.internalRange, "This operator is not currently supported");
      }
    }

    // Support custom operators
    else if (leftType != context.errorType) {
      var name = node.internalRange.toString();
      var symbol = leftType.findMember(
        kind == NodeKind.NOT_EQUAL ? "==" :
        kind == NodeKind.LESS_THAN_EQUAL ? ">" :
        kind == NodeKind.GREATER_THAN_EQUAL ? "<" :
        name,
        ScopeHint.NOT_UNARY);

      // Automatically call the function
      if (symbol != null) {
        left = createMemberReference(left.remove(), symbol).withRange(node.range).withInternalRange(node.internalRange);
        right.remove();

        if (kind == NodeKind.NOT_EQUAL ||
            kind == NodeKind.LESS_THAN_EQUAL ||
            kind == NodeKind.GREATER_THAN_EQUAL) {
          var call = createCall(left);
          call.appendChild(right);
          node.kind = NodeKind.NOT;
          node.appendChild(call.withRange(node.range).withInternalRange(node.range));
        }

        else {
          node.appendChild(left);
          node.appendChild(right);
          node.kind = NodeKind.CALL;
        }

        node.resolvedType = null;
        resolveAsExpression(context, node, parentScope);
      }

      // Automatically implement equality operators
      else if (kind == NodeKind.EQUAL || kind == NodeKind.NOT_EQUAL) {
        node.resolvedType = context.boolType;

        if (leftType != context.errorType && rightType != context.errorType && leftType != rightType &&
            !canConvert(context, right, leftType, ConversionKind.IMPLICIT) &&
            !canConvert(context, left, rightType, ConversionKind.IMPLICIT)) {
          context.log.error(node.internalRange, StringBuilder_new()
            .append("Cannot compare type '")
            .append(leftType.toString())
            .append("' with type '")
            .append(rightType.toString())
            .appendChar('\'')
            .finish());
        }
      }

      else {
        context.log.error(node.internalRange, StringBuilder_new()
          .append("Cannot use binary operator '")
          .append(name)
          .append("' with type '")
          .append(leftType.toString())
          .appendChar('\'')
          .finish());
      }
    }
  }

  else {
    assert(false);
  }
}